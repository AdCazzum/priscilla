/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

import {
  CalimeroApp,
  Context,
} from '@calimero-network/calimero-client';

// Generated types

export interface AnswerResult {
  message: ChatMessage;
  guess_was_correct: boolean;
}

export interface ChatMessage {
  id: number;
  sender: string;
  role: string;
  content: string;
  timestamp_ms: number;
}

export interface GameInfo {
  admin: string | null;
  player_one: string | null;
  player_two: string | null;
  stage: GameStage;
  secret_set: boolean;
  total_messages: number;
  max_messages: number;
  awaiting_player: string | null;
}

export type GameStagePayload =
  | { name: 'NotStarted' }
  | { name: 'WaitingForSecret' }
  | { name: 'WaitingForQuestion' }
  | { name: 'WaitingForAnswer' }
  | { name: 'Completed' }

export const GameStage = {
  NotStarted: (): GameStagePayload => ({ name: 'NotStarted' }),
  WaitingForSecret: (): GameStagePayload => ({ name: 'WaitingForSecret' }),
  WaitingForQuestion: (): GameStagePayload => ({ name: 'WaitingForQuestion' }),
  WaitingForAnswer: (): GameStagePayload => ({ name: 'WaitingForAnswer' }),
  Completed: (): GameStagePayload => ({ name: 'Completed' }),
} as const;

export interface GuessResult {
  guess_was_correct: boolean;
}







export type AbiEvent =
  | { name: "MessageAdded" }
  | { name: "HistoryCleared" }
  | { name: "GameCreated" }
  | { name: "SecretSet" }
  | { name: "SecretGuessed" }
  | { name: "StageChanged" }
;


/**
 * Utility class for handling byte conversions in Calimero
 */
export class CalimeroBytes {
  private data: Uint8Array;

  constructor(input: string | number[] | Uint8Array) {
    if (typeof input === "string") {
      // Hex string
      this.data = new Uint8Array(
        input.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || []
      );
    } else if (Array.isArray(input)) {
      // Number array
      this.data = new Uint8Array(input);
    } else {
      // Uint8Array
      this.data = input;
    }
  }

  toArray(): number[] {
    return Array.from(this.data);
  }

  toUint8Array(): Uint8Array {
    return this.data;
  }

  static fromHex(hex: string): CalimeroBytes {
    return new CalimeroBytes(hex);
  }

  static fromArray(arr: number[]): CalimeroBytes {
    return new CalimeroBytes(arr);
  }

  static fromUint8Array(bytes: Uint8Array): CalimeroBytes {
    return new CalimeroBytes(bytes);
  }
}

/**
 * Convert CalimeroBytes instances to arrays for WASM compatibility
 */
function convertCalimeroBytesForWasm(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (obj instanceof CalimeroBytes) {
    return obj.toArray();
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertCalimeroBytesForWasm(item));
  }

  if (typeof obj === "object") {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertCalimeroBytesForWasm(value);
    }
    return result;
  }

  return obj;
}

/**
 * Convert arrays back to CalimeroBytes instances from WASM responses
 */
function convertWasmResultToCalimeroBytes(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (Array.isArray(obj) && obj.every(item => typeof item === "number")) {
    return new CalimeroBytes(obj);
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertWasmResultToCalimeroBytes(item));
  }

  if (typeof obj === "object") {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = convertWasmResultToCalimeroBytes(value);
    }
    return result;
  }

  return obj;
}

export class AbiClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }

  /**
   * init
   */
  public async init(): Promise<void> {
    const response = await this.app.execute(this.context, 'init', {});
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * create_game
   */
  public async createGame(params: { admin: string; player_one: string; player_two: string }): Promise<GameInfo> {
    const response = await this.app.execute(this.context, 'create_game', params);
    if (response.success) {
      return response.result as GameInfo;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * set_secret
   */
  public async setSecret(params: { requester: string; secret: string }): Promise<GameInfo> {
    const response = await this.app.execute(this.context, 'set_secret', params);
    if (response.success) {
      return response.result as GameInfo;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * submit_question
   */
  public async submitQuestion(params: { player: string; content: string }): Promise<ChatMessage> {
    const response = await this.app.execute(this.context, 'submit_question', params);
    if (response.success) {
      return response.result as ChatMessage;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * submit_answer
   */
  public async submitAnswer(params: { player: string; content: string; guess: string | null }): Promise<AnswerResult> {
    const response = await this.app.execute(this.context, 'submit_answer', params);
    if (response.success) {
      return response.result as AnswerResult;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * messages
   */
  public async messages(params: { offset: number | null; limit: number | null }): Promise<ChatMessage[]> {
    const response = await this.app.execute(this.context, 'messages', params);
    if (response.success) {
      return response.result as ChatMessage[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * message_by_id
   */
  public async messageById(params: { id: number }): Promise<ChatMessage> {
    const response = await this.app.execute(this.context, 'message_by_id', params);
    if (response.success) {
      return response.result as ChatMessage;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * clear_history
   */
  public async clearHistory(params: { requester: string }): Promise<void> {
    const response = await this.app.execute(this.context, 'clear_history', params);
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * set_max_messages
   */
  public async setMaxMessages(params: { requester: string; max_messages: number }): Promise<void> {
    const response = await this.app.execute(this.context, 'set_max_messages', params);
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * game_info
   */
  public async gameInfo(): Promise<GameInfo> {
    const response = await this.app.execute(this.context, 'game_info', {});
    if (response.success) {
      return response.result as GameInfo;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * check_guess
   */
  public async checkGuess(params: { guess: string }): Promise<GuessResult> {
    const response = await this.app.execute(this.context, 'check_guess', params);
    if (response.success) {
      return response.result as GuessResult;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_secret
   */
  public async getSecret(params: { requester: string }): Promise<string> {
    const response = await this.app.execute(this.context, 'get_secret', params);
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * debug_reveal_secret
   */
  public async debugRevealSecret(): Promise<string> {
    const response = await this.app.execute(this.context, 'debug_reveal_secret', {});
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

}